# 02 Recoil 的理念和特性

本文，我们将正式开始学习 Recoil 。



<br>

## Recoil 的理念

> 天下苦 Redux、MobX 久亦。

> recoil 单词本意为：反冲、后坐力



<br>

Recoil 2020 年 5 月刚发布的时候，在 React Europe 2020 大会上，Recoil 作者详细阐述了 React 状态管理现状，以及第一次对外介绍 Recoil 的理念思想。

该视频地址为：https://www.youtube.com/watch?v=_ISAA_Jt9kI

<br>

通过下面视频截图，我们来讲解一下 Recoil 对于状态管理的理念思想。

![](https://www.puxiao.com/temp/recoil-tutorial/imgs/p2.jpg)



> 以下内容，仅仅为目前我个人的理解，若有不对，请自己原谅自己。

<br>

#### Recoil对于状态管理的理念思想

<br>

**我们先虚构一个场景：**

假设我们的 React 场景中左右各有一个模块(组件)，为了方便我们将其称呼为 模块(组件)A、模块(组件)B。

> 为了简便，下面直接将称呼为 组件A、组件B

那么有可能会有以下情况：

1. 组件A 中定义了 10 个变量
2. 组件B 中定义了 10 个变量
3. 组件A 中有 3 个变量需要受到 组件B 的控制(读/写)
4. 组件B 中有 3 个变量需要受到 组件A 的控制(读/写)

也就是说，组件A 和 组件B 一共有 6 个变量要相互控制(读/写)。

假设我们分别对这 6 个变量命名为 a、b、c、d、e、f，那么 **所谓 React 状态管理，就是我们如何去组织、储存、管理这 6 个变量。**



<br>

**看一下传统的状态管理是怎么做的？**

1. useState + useContext + useReducer：将这 6 个变量全部定义在我们自定义的 GlobalContent 中。
2. Redux：定义一个最大的数据对象，然后将这 6 个变量存放在该数据对象中
3. MobX：...

当我们需要去读写某个变量时，都需要去访问这个最顶层的超级大数据对象集合。

> 不同的状态库，他们的主要差别体现在如何获取、如何修改变量值而已。

我们上面虚构的场景，只有 组件A、组件B，那如果整个应用还有 组件C、组件D...，当所有组件都把变量储存在顶层的超大数据集合对象中，那无疑是非常臃肿的，读写变量时肯定需要很大的心智负担。



<br>

重点来了，那 Recoil 又会怎样去做呢？

**Recoil也是将所有变量都存放在顶层超大数据集合中，但是 Recoil 充分利用 React Hooks 函数，让你可以做到将每个变量进行最小单位的拆分和独立，也就是体现出 原子性。**



<br>

**原子性？**

原子的应为单词为：atom，原子 是构成物质的最小单位。

在化学上认为 原子 是化学反应中最小且不可再分割的元素。

但是在物理上，原子 实际上是由 电子 和 原子核 构成，若想分开 电子和原子核，则需要宇宙级、超乎想象的巨大的力量才可以。

我们就认为：原子是足够小，小到不可再分割的最小单位即可。



<br>

对比一下前面我们提到的传统状态管理方式(例如 Redux、MobX)，我们使用到了 “非常臃肿” 这个词。

Recoil 的优势就是原子性，降低臃肿度，让我们以非常小、灵活的方式来管理组织数据状态。

> 原子性 也出现在 React 的特性介绍中。

<br>



本文不会涉及 Recoil 的具体代码用法，只是讲解 Recoil 的哲学思想。



<br>

回到我们虚构的示例中，那 Recoil 究竟是怎么做的？是如何管理这 6 个变量呢？



//本文未完，待续...