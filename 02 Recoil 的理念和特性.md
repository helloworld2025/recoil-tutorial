# 02 Recoil 的理念和特性

本文，我们将正式开始学习 Recoil 。



<br>

## Recoil 的理念

> 天下苦 Redux、MobX 久亦。

> recoil 单词本意为：反冲、后坐力



<br>

Recoil 2020 年 5 月刚发布的时候，在 React Europe 2020 大会上，Recoil 作者详细阐述了 React 状态管理现状，以及第一次对外介绍 Recoil 的理念思想。

该视频地址为：https://www.youtube.com/watch?v=_ISAA_Jt9kI

<br>

通过下面视频截图，我们来讲解一下 Recoil 对于状态管理的理念思想。

![](https://www.puxiao.com/temp/recoil-tutorial/imgs/p2.jpg)



> 以下内容，仅仅为目前我个人的理解，若有不对，请自己原谅自己。

<br>

#### Recoil对于状态管理的理念思想

<br>

**我们先虚构一个场景：**

假设我们的 React 场景中左右各有一个模块(组件)，为了方便我们将其称呼为 模块(组件)A、模块(组件)B。

> 为了简便，下面直接将称呼为 组件A、组件B

那么有可能会有以下情况：

1. 组件A 中定义了 10 个变量
2. 组件B 中定义了 10 个变量
3. 组件A 中有 3 个变量需要受到 组件B 的控制(读/写)
4. 组件B 中有 3 个变量需要受到 组件A 的控制(读/写)

也就是说，组件A 和 组件B 一共有 6 个变量要相互控制(读/写)。

假设我们分别对这 6 个变量命名为 a、b、c、d、e、f，那么 **所谓 React 状态管理，就是我们如何去组织、储存、管理这 6 个变量。**



<br>

**看一下传统的状态管理是怎么做的？**

1. useState + useContext + useReducer：将这 6 个变量全部定义在我们自定义的 GlobalContent 中。
2. Redux：定义一个最大的数据对象，然后将这 6 个变量存放在该数据对象中
3. MobX：...

当我们需要去读写某个变量时，都需要去访问这个最顶层的超级大数据对象集合。

> 不同的状态库，他们的主要差别体现在如何获取、如何修改变量值而已。

我们上面虚构的场景，只有 组件A、组件B，那如果整个应用还有 组件C、组件D...，当所有组件都把变量储存在顶层的超大数据集合对象中，那无疑是非常臃肿的，读写变量时肯定需要很大的心智负担。



<br>

重点来了，那 Recoil 又会怎样去做呢？

**Recoil也是将所有变量都存放在顶层超大数据集合中，但是 Recoil 充分利用 React Hooks 函数，让你可以做到将每个变量进行最小单位的拆分和独立，也就是体现出 原子性。**



<br>

**原子性？**

原子的应为单词为：atom，原子 是构成物质的最小单位。

> 请你记住 atom 这个单词

在化学上认为 原子 是化学反应中最小且不可再分割的元素。

但是在物理上，原子 实际上是由 电子 和 原子核 构成，若想分开 电子和原子核，则需要宇宙级、超乎想象的巨大的力量才可以。

我们就认为：原子是足够小，小到不可再分割的最小单位即可。



<br>

对比一下前面我们提到的传统状态管理方式(例如 Redux、MobX)，我们使用到了 “非常臃肿” 这个词。

Recoil 的优势就是原子性，降低臃肿度，让我们以非常小、灵活的方式来管理组织数据状态。

> 原子性 也出现在 React 的特性介绍中。

<br>



本文不会涉及 Recoil 的具体代码用法，只是讲解 Recoil 的哲学思想。



<br>

回到我们虚构的示例中，那 Recoil 究竟是怎么做的？是如何管理这 6 个变量呢？

### Recoil 用法过程概述

第1步：使用一个特有标签来包裹住整个项目的 <App /\>  标签，即相当于创建了一个超级大的状态管理对象。

> 对于具体的子组件而言，无需使用任何引入标签或代码。
>
> 你可以变相理解为子组件根本不知道有这样一个超级大的顶层状态管理对象。



<br>

第2步：在组件A中，使用 Recoil 提供的特殊函数来定义和管理数据。

例如我们在组件A中，使用一个字符串类型的 key，作为变量 a 的 ID，然后定义变量 a。

> 具体是什么函数暂且不提，你可以简单想象成类似 useState 那样。



<br>

第3步：在组件B中，使用 Recoil 提供的不同的钩子函数(hooks)，通过字符串类型的 key，找到变量 a ，并获取变量 a 的不同权限。

1. 获取读和写的权限
2. 只获取读的权限
3. 只获取写的权限



<br>

此时，在组件A 和 组件B 中，各自存在一份对变量 a 的或读、或写 的能力。那么在这些子组件内就可以像使用内部变量一样使用变量 a。

当其中一方修改了变量 a 的值，那么 Recoil 会自动通知另一方，并且将另一方也进行重新渲染。

> 假设有一个组件C，它也拥有变量 a 的读的权利，那么 Recoil 也会通知并渲染组件C
>
> 假设有一个组件D，他只拥有变量 a 的写的权利，没有读的权利，那么 Recoil 是不会、也无需去重新渲染组件D的。



<br>

**Recoil 可以让我们非常方便地 定义、读写全局变量，就好像该变量本身就是在组件内似的。**

**唯一的心智负担，是我们需要给不同的变量分别赋予一个全局唯一的标识(ID)。**

> 这种全局唯一 ID 的做法估计是借鉴了传统数据库的思路。
>
> 传统数据库中每一条信息都需要有一个全局唯一的 ID，也就是通过这个独一无二的 ID 可以精准定位每一条数据。



<br>

你以为就这些，就完了？还没有，Recoil 的招还多着呢。

**Recoil还可以通过衍生(派生)，将变量进行更加灵活的拆分或组合。**

**什么是衍生(派生)？**

> 请注意，在本文中无论使用 “衍生” 还是 “派生”，所表达的意思是相同的。

所谓变量的 衍生(派生)，无非 2 个方向：

1. **拆分**：从一个复杂变量中，提取得到一个更加细小、简单的变量
2. **组合**：将多个变量，通过组合，形成一个更加复杂的变量



<br>

**举个 拆分 的例子：**

假设通过 Recoil 定义了一个 object 类型的变量 obj，该变量结构类型为：

```
{
  num:number,
  arr:any[],
  date:Date
}
```

假设现在有一个组件E，该组件只关心 obj.arr 值的变化，按照传统的状态管理思路，你一定需要将 obj 完整引入，然后通过 obj.arr 这种形式去找到 arr 。

如果使用Recoil 提供的特殊操作函数，可以让你无需引入整个 obj，只引入 arr 。

> 对于组件E 而言，他不知道 obj 的存在，他只知道 arr。



<br>

**举个 组合 的例子：**

假设现在有 2 个变量，objA、objB，他们具有相同的数据结构：

```
{
  width:number,
  height:number,
  x:number,
  y:number
}
```

假设现在有一个组件F，该组件需要获取 objA 和 objB 在水平位置之间的间隔距离。那么按照传统的状态管理思路，你需要做的事情是：

1. 组件F 引入 objA、objB

2. 在组件F 内计算出 2 者水平位置之间的间隔距离，有可能你的代码如下

   ```
   const offsetX = objB.x - objA.x - objA.width
   ```

如果使用 Recoil 提供特殊的操作函数，可以让你将上述计算操作单独剥离，offsetX 的值被单独储存起来。

这样操作的结果就是：

1. 当和 offsetX 有关的任意变量(objB.x、objA.x、objA.width)发生变化时，都会从新计算一遍 offsetX 的值。

2. 组件F 无需引入 objA、objB，只需引入 offsetX

   > 对于组件F 而言，他不知道 objA、objB的存在，他只知道 offsetX

3. 当 offsetX 的值发生变化时，Recoil 自动通知 组件F，且进行组件更新。



<br>

通过变量的衍生(派生)，也就是将变量进行 拆分和组合，可以解放手脚和思想，让 React 项目各个模块(组件)之间的变量使用更加灵活。



<br>

**Recoil还可以提供变量发生变化后对应的钩子函数。**

>  类似 useEffect

让我们更加多一层维度来监控变量的变化，并作出相应操作。



<br>

你以为就这些，就完了？还没有，Recoil 的招还多着呢。

**Recoil 还提供异步获取数据的能力。**

**Recoil 还提供对路由的修改和解析能力。**

> Recoil 可以将变量与路由(url和 url参数) 进行绑定结合，方便我们将不同状态通过 url参数 分享给其他人。

**Recoil 还提供... Recoil 目前还在不断更新升级中，或许将来还能够提供更为复杂的功能。**

> 请注意，这里说的复杂是指 Recoil 开发者，对于我们使用者而言 Recoil 几乎没有太大的学习和升级负担。



<br>

## Recoil的特性总结



![](https://puxiao.com/temp/recoil-tutorial/imgs/p3.jpg)

#### 特性 1：具有原子性特征、学习成本低

Recoil 的一些用法几乎和普通的 React hooks 用法一模一样，你完全可以使用 React Hooks 的思考方式去使用 Recoil。

这样我们就以一种非常低的学习成本，可以快速构建 React 状态管理。

> 不同于 Redux、MobX，前期学习成本偏高。



<br>这就是为什么该特性使用 React 图标的原因：**像 React Hooks 一样思考和使用即可。**



<br>

<br>

![](https://puxiao.com/temp/recoil-tutorial/imgs/p4.jpg)

#### 特性 2：具有派生性特征、支持数据异步查询

关于派生性，在前面理念中，我们已经讲解了 数据的 拆分和组合，这里不再过多阐述。

数据异步查询，我们会在后面实际使用过程中，详细讲解。



<br>

请观察该特性所使用的图标：**数据局部可以不连贯、不完整，可以自由拆分或组合，甚至是异步。**



<br>

<br>

![](https://puxiao.com/temp/recoil-tutorial/imgs/p5.jpg)

#### 特性 3：跨应用观察

第一层含义：全局观察所有的变量状态

第二层含义：可以将React中的变量与路由(url和url参数)进行绑定

> 当React中的变量发生变化时改变路由(url和url参数)，反之亦然，路由(url和url参数)的变化也可以改变React中的变量。



<br>

请观察该特性所使用的图标：**数据整体统一连贯，包括路由都在Recoil管控范围内**



<br>

至此，Recoil 的理念和特性讲解完毕。

接下来，开始真正投入到 Recoil 具体的代码学习中。

